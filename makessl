#!/bin/bash
#
# made by Michael Tanner
# https://github.com/thonixx/
#
# created at 24th of September 2012
# Use "git whatchanged" to get a more accurate date

#                                            #                        #  ""#      "                 
#   mmm    m mm   m mm   mmm    m mm         # mm    mmm   m mm    mmm#    #    mmm    m mm    mmmm 
#  #"  #   #"  "  #"  " #" "#   #"  "        #"  #  "   #  #"  #  #" "#    #      #    #"  #  #" "# 
#  #""""   #      #     #   #   #            #   #  m"""#  #   #  #   #    #      #    #   #  #   # 
#  "#mm"   #      #     "#m#"   #            #   #  "mm"#  #   #  "#m##    "mm  mm#mm  #   #  "#m"# 
#                                                                                              m  # 
#                                                                                               ""  

# function for error handling
function catch_errors() {
	# show a nice dialog window when installed
	if [ "$(which dialog)" ]
	then
		dialog --title " Error " --infobox "Script aborted due to erros.\nPlease check for the log file in '/tmp/makessl.log'." 0 0
	else
		echo 'Aborting script due to errors! Please check logfile.'
	fi

	# exit with exit code of last failed script
	exit $?
}

# for error handling
trap catch_errors ERR;


#                                              m                        
#  mmmm    mmm    m mm   mmm   mmmmm   mmm   mm#mm   mmm    m mm   mmm  
#  #" "#  "   #   #"  " "   #  # # #  #"  #    #    #"  #   #"  " #   " 
#  #   #  m"""#   #     m"""#  # # #  #""""    #    #""""   #      """m 
#  ##m#"  "mm"#   #     "mm"#  # # #  "#mm"    "mm  "#mm"   #     "mmm" 
#  #                                                                    
#  " 


# OK, now we use getopt from util-linux
usage ()
{
echo "Usage:
	${0##*/}	-d domain [other-options]

Overview:
	Generate an SSL certificate with some options.

	Required option
	****
	-d domain		Domain (asterisk for wildcard allowed)
	

	Other options
	****
	-c country		Country the company resides
	-s state		State or canton of the company
	-l locality		City or village
	-o organisation		Name of your company
	-u unit			Organisation unit
	

	Non-certificate-related options
	****
	-p|--prefix		Prefix for file names (e.g. SSL_)
	-f folder		Where to generate the CSR and private key
				Default: ($(pwd))
	--private-key		Specify a custom private key
	--selfsign		Self sign the certificate
	--days			Set validity period for selfsigned certificate
				Default: 365 days
	--force			Force overwriting private key
				Can not be used with --renewal
	--renewal		Uses existing key for renewal
				Can not be used with --force
	--sha256		Use SHA256 instead of default SHA1
        -h|--help		This help"
}
PARAM=`getopt -o d:c:s:l:o:u:p:f:h --long help,selfsign,days:,renewal,force,prefix:,private-key:,sha256 -- "$@"`

if [ "$?" -ne "0" ] ; then usage ; exit 1 ; fi

# ok I'm honest.. This part is copied from an existing script of a friend
eval set -- "$PARAM"
while true ; do
        case "$1" in
                -d) domain="${2}" ; shift 2 ;;
                -c) country="${2}"; shift 2 ;;  
		-s) state="${2}"; shift 2 ;;  
                -l) locality="${2}"; shift 2 ;;  
                -o) org="${2}"; shift 2 ;;  
                -u) orgunit="${2}"; shift 2 ;;  
                -f) customfolder="${2}"; shift 2 ;;  
                -p) prefix="${2}"; shift 2 ;;  
		--selfsign) selfsign="true"; shift ;;
		--days) days="${2}"; shift 2 ;;
		--prefix) prefix="${2}"; shift 2 ;;
		--private-key) pkey="${2}"; shift 2 ;;
		--force) force="true"; shift ;;
		--renewal) renewal="true"; shift ;;
		--sha256) sha256="true"; shift ;;
                -h|--help) usage ; exit 0 ;;
                --) shift ; break ;;
                *) echo -e "Some weird error..\nI'm sorry.\nSomething with parameters is going wrong." ; exit 1 ;;
        esac
done

# we need at least a domain
if [ -z "$domain" ]; then usage ; exit 1; fi

                                                                                                  
#                  m    #            
#  mmmm    mmm   mm#mm  # mm    mmm  
#  #" "#  "   #    #    #"  #  #   " 
#  #   #  m"""#    #    #   #   """m 
#  ##m#"  "mm"#    "mm  #   #  "mmm" 
#  #                                 
#  " 


# special thing for myself. i always want to have a prefix :D
if [ "$(hostname)" == "mitan" ] && [ -z "$prefix" ]
then
	prefix="SSL_"
fi

# build the filename used for key/csr
# replace asterisk with "wildcard" due to builtin shell search
filename="$prefix${domain/\*/wildcard}"

# define debian standard path
# for later implementation.. this could be useful with an option I think.. :/
certdebpath='/etc/ssl/certs/' # linux standard
keydebpath='/etc/ssl/private/' # linux standard

# default path is current working directory
keypath="$(pwd)/"
certpath="$(pwd)/"

# here are the default paths defined
keypath="$(echo $keypath | sed -e "s/\/*$//")/" # delete trailing/multiple slashes
certpath="$(echo $certpath | sed -e "s/\/*$//")/" # its just for beauty (and proper directory handling..)

# define logfile
logfile="/tmp/makessl.log"
# create logfile with touch
touch $logfile

# we need a folder
if [ "$customfolder" ]; # if custom folder on cli is defined
then
	# create folder if it does not exist
	if [ ! -d $customfolder ] ; then mkdir -p $customfolder >> $logfile 2>&1; fi
	# print error if it fails (due to permissions or something like that)
	if [ ! -d $customfolder ] ; then echo "Could not create directory $customfolder for you." 2>&1 | tee -a $logfile ; fi

	# define the custom paths
	keypath="$(echo $customfolder | sed -e "s/\/*$//")/"
	certpath="$(echo $customfolder | sed -e "s/\/*$//")/"
fi

# define validity period for selfsigned certificate
# option will only be used if selfsigned certificate is being generated
if [ -z "$days" ]
then
	days=365
fi


#                  "                    m                  #                   
#  mmmm    m mm  mmm    m   m   mmm   mm#mm   mmm          #   m   mmm   m   m 
#  #" "#   #"  "   #    "m m"  "   #    #    #"  #         # m"   #"  #  "m m" 
#  #   #   #       #     #m#   m"""#    #    #""""         #"#    #""""   #m#  
#  ##m#"   #     mm#mm    #    "mm"#    "mm  "#mm"         #  "m  "#mm"   "#   
#  #                                                                      m"   
#  "                                                                     ""

# default value of $ownpkey to false
ownpkey="false"

# check for custom private key
if [ "$pkey" ]
then
	# check if custom key exists
	if [ -f $pkey ]
	then
		# debug: inform about custom private key
		echo "Using the following custom private key: $pkey" >> $logfile

		# put custom private key in variable
		keyfile="$pkey"
		ownpkey="true" # this is used for a later check if custom private key was used

		if [ "$force" ]
		then
			# if custom key is specified (and exists) you can not
			# overwrite the custom key for security reasons
			echo 'You can not overwrite your custom private key.'
			echo 'Move it away or delete the private key first.'
			# debug: inform about force option
			echo 'Tried to overwrite custom private key' >> $logfile
			exit 1
		fi
	else
		# print error when private key does not exist
		echo 'The private key seems to not exist. Maybe permission problem?' | tee -a $logfile
		exit 1
	fi
else
	# take the default name for private key if it should be created
	keyfile="$keypath$filename.key"
	ownpkey="false" # this is used for a later check if custom private key was used
fi

# check if private key already exists and if renewal is not set
if [ -f $keyfile ] && [ "$force" != "true" ] && [ "$renewal" != "true" ] && [ "$ownpkey" != "true" ]
then
	echo '------------------------ Warning ------------------------'
	echo 'Private key already exists. Use --force to overwrite it.'
	echo 'Think about it carefully!'
	exit 1

# check if --force is set when --renewal is not set
elif [ "$force" == "true" ] && [ -f $keyfile ] && [ "$renewal" != "true" ] && [ "$ownpkey" != "true" ]
then
	# remove existing private key
	rm -v $keyfile >> $logfile 2>&1
	if [ "$?" -ne 0 ]
	then
		# print error (e.g. insufficient rights)
		echo 'Could not remove private key. :(' | tee -a $logfile
		echo 'Maybe I do not have permission to do that.'
		exit 1
	else
		# warn if private key was overwritten
		echo '------------------------- Info --------------------------'
		echo 'Existing private key overwritten with --force.' | tee -a $logfile
		echo 'It is gone. Forever. Really. No joke. For sure ;).'
	fi
fi


# 
#   mmm   m   m  mmmmm  mmmmm   mmm    m mm  m   m 
#  #   "  #   #  # # #  # # #  "   #   #"  " "m m" 
#   """m  #   #  # # #  # # #  m"""#   #      #m#  
#  "mmm"  "mm"#  # # #  # # #  "mm"#   #      "#   
#                                             m"   
#                                            ""


# prints the common name
echo ''
echo '---------------- Certificate Common Name ----------------'
echo $domain
echo ''

# prints the saving paths
echo '-------------------------- Path -------------------------'
if [ "$ownpkey" != "true" ]
then
	# just print one path if both is the same
	echo "Key/CSR: $certpath"
else
	# print both if different (e.g. debian standard path)
	echo "Private key: $keyfile"
	echo "Cert/CSR: $certpath"
fi
echo "Log file: $logfile"
echo ''


#                                                     "                 
#  mmmm    m mm   mmm    mmm    mmm    mmm    mmm   mmm    m mm    mmmm 
#  #" "#   #"  " #" "#  #"  "  #"  #  #   "  #   "    #    #"  #  #" "# 
#  #   #   #     #   #  #      #""""   """m   """m    #    #   #  #   # 
#  ##m#"   #     "#m#"  "#mm"  "#mm"  "mmm"  "mmm"  mm#mm  #   #  "#m"# 
#  #                                                               m  # 
#  "                                                                ""  
# 


# build certificates subject string if exists as parameter
if [ "$country" ] ; then subject="/C=$country" ; fi
if [ "$state" ] ; then subject="$subject/ST=$state" ; fi
if [ "$locality" ] ; then subject="$subject/L=$locality" ; fi
if [ "$org" ] ; then subject="$subject/O=$org" ; fi
if [ "$orgunit" ] ; then subject="$subject/OU=$orgunit" ; fi
if [ "$domain" ] ; then	subject="$subject/CN=$domain" ; fi

# use existing key for CSR if it exists (should be checked above .. but this is more secure if sth fails)
if [ -f $keyfile ] && [ "$renewal" == "true" ] || [ -f $keyfile ] && [ "$ownpkey" == "true" ]
then
	# this will use the existing key for renewal/"rerequest" csr
	if [ "$sha256" == 'true' ]; then
		openssl req -out $certpath$filename.csr -new -sha256 -key $keyfile -subj "$subject" >> $logfile 2>&1
	else
		openssl req -out $certpath$filename.csr -new -key $keyfile -subj "$subject" >> $logfile 2>&1
	fi
fi

# overwrite existing key or generate a new one
if [ -f $keyfile ] && [ "$force" == "true" ] || [ ! -f $keyfile ]
then
	# this will overwrite existing keys with the same name due to openssl command defaults
	if [ "$sha256" == 'true' ]; then
		openssl req -newkey rsa:2048 -subj "$subject" -nodes -sha256 -keyout $keyfile -out $certpath$filename.csr >> $logfile 2>&1
	else
		openssl req -newkey rsa:2048 -subj "$subject" -nodes -keyout $keyfile -out $certpath$filename.csr >> $logfile 2>&1
	fi
fi

# create self signed if user wishes that..
# because of lazyness (cacert.org/startssl.com) or whatever o.O
if [ -f $keyfile ] && [ "$selfsign" == "true" ]
then
	# this will genereate a self signed certificate
	if [ "$sha256" == 'true' ]; then
		openssl x509 -req -sha256 -days $days -in $certpath$filename.csr -signkey $keyfile -out $certpath$filename.crt >> $logfile 2>&1
	else
		openssl x509 -req -days $days -in $certpath$filename.csr -signkey $keyfile -out $certpath$filename.crt >> $logfile 2>&1
	fi
fi

# now comes the CSR/certificate thing
if [ "$?" -eq 0 ]
then
	if [ -f $certpath$filename.crt ] && [ "$selfsign" == "true" ]
	then
		# print some happyness if cert succeeded
		echo '------------------------ Success ------------------------'
		echo 'Certificate generated successfully.' | tee -a $logfile
		echo ''
	else
		# print some happyness if csr succeeded
		echo '------------------------ Success ------------------------'
		echo 'Certificate signing request generated successfully.' | tee -a $logfile
		echo ''
	fi

	# set rights on csr
	chmod 644 $certpath$filename.csr 2>&1 | tee -a $logfile
	
	# print error if chmod failed
	if [ "$?" -eq 0 ]
	then
		echo 'CSR: rights on 644'
	else
		echo 'Could not set proper rights on CSR.'
	fi

	# set rights on private key
	chmod 600 $keyfile >> $logfile 2>&1

	# print error if chmod failed
	if [ "$?" -eq 0 ]
	then
		echo 'Private key: rights on 600'
	else
		echo 'Could not set proper rights on private key.'
	fi
	echo ''
	
	# check private key owner which should be root
	if [ -f "$keyfile" ]
	then
		pkeyowner=`ls -l $keyfile | awk '{ print $3 }'`
	fi

	# removed this part because most of the time the generated key/cert is not used straight away
	# if [ "$pkeyowner" != "root" ] && [ -f $keyfile ]
	# then
	# 	echo '!!!!!!!!!!!!!!!!!!!!!!!! Warning !!!!!!!!!!!!!!!!!!!!!!!!'
	# 	echo 'Owner of private key should be root.'
	# fi
	
	if [ "$selfsign" != "true" ]
	then
		# show the generated csr (to copy/paste)
		echo ''
		cat $certpath$filename.csr

		# paste to clipboard if xclip is installed
		if [ "$(which xclip)" ]
		then
			cat $certpath$filename.csr | xclip
			cat $certpath$filename.csr | xclip -selection c
		fi
	fi
else
	echo "
Something went wrong with the openssl command, sorry.
I removed the trash for you. Just try it again.

Oh and have a look at the logfile: $logfile
	"
	# clean up the mess
	rm -v $certpath$filename.csr >> $logfile 2>&1
	rm -v $certpath$filename.crt >> $logfile 2>&1
	# remove when not renewal
	if [ "$renewal" != "true" ] && [ "$ownpkey" != "true" ]
	then
		rm -v $keyfile >> $logfile 2>&1
	fi
	exit 1
fi

# everything okay here
echo "Script ended successfully" >> $logfile
exit 0
