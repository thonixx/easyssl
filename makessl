#!/bin/bash
# made by Michael Tanner
# 24. September 2012

# OK, now we use getopt from util-linux
usage ()
{
echo "
Usage: ${0##*/}	-d domain
		[-c country] [-s state/canton] [-l city/village] [-o organisation] [-u orgunit] [-e email]
		[-f folder] [--private-key] [--selfsign] [--renewal|force] [-h/--help]

	most important thing:
	****
	-d domain       domain (asterisk for wildcard allowed)
	

	optional (required for class 3/EV):
	****
	-c country		Country the company resides
	-s state/canton		State or canton of the company
	-l city/village		City or village
	-o organisation		Name of your company
	-u unit			Organisation unit
	

	optional too:
	****
	-f folder		where to generate the CSR and private key
				Default: (`pwd`)
	--private-key		specify a custom private key
	--selfsign		self sign the certificate
	--force			force overwriting private key
	--renewal		uses existing key for renewal
	

	I need help:
	****
        -h/--help       this help
"
}
PARAM=`getopt -o d:c:s:l:o:u:f:h --long help,selfsign,renewal,force,private-key: -- "$@"`

if [ "$?" != "0" ] ; then usage ; exit 1 ; fi

eval set -- "$PARAM"
while true ; do
        case "$1" in
                -d) domain="${2}" ; shift 2 ;;
                -c) country="${2}"; shift 2 ;;  
		-s) state="${2}"; shift 2 ;;  
                -l) locality="${2}"; shift 2 ;;  
                -o) org="${2}"; shift 2 ;;  
                -u) orgunit="${2}"; shift 2 ;;  
                -f) folder="${2}"; shift 2 ;;  
		--selfsign) selfsign="true"; shift ;;
		--private-key) pkey="${2}"; shift 2 ;;
		--force) force="true"; shift ;;
		--renewal) renewal="true"; shift ;;
                -h|--help) usage ; exit 0 ;;
                --) shift ; break ;;
                *) echo -e "Some weird error..\nI'm sorry." ; exit 1 ;;
        esac
done

# we need at least a domain
if [ -z "$domain" ]; then echo "****
Can not execute script without domain.

Example: ${0##*/} -d domain.tld
****" ; usage ; exit 1; fi


############################################################### PATH THINGIES
# define debian standard path
# for later implementation.. this could be useful with an option I think.. :/
certdebpath='/etc/ssl/certs/' # debian standard
keydebpath='/etc/ssl/private/' # debian standard

# default path is current working directory
keypath=`pwd`
certpath=`pwd`

# delete trailing slashes // at this state it does not work.. but will edit this part later..
# its just for beauty..
#keypath=${keypath%/}/
#certpath=${certpath%/}/

# we need a folder
if [ "$folder" ];
then
	# I decided not to print the default path
	# echo "Default paths: $keypath and $certpath";
	# echo "No custom folder specified.";
	
	# create folder if it does not exist
	if [ ! -d $folder ] ; then mkdir -p $folder ; fi
	# print error if it fails (due to permissions or something like that)
	if [ $? -ne 0 ] ; then echo "Could not create directory $folder for you." ; fi

	# define paths
	keypath=${folder%/}/
	certpath=${folder%/}/
else
	folder=${certpath%/}/
fi

# check if specific private key exists
if [ -f $pkey ] && [ "$pkey" ]
then
	# define where the private key is
	keyfile=$pkey
	ownpkey="true"
	if [ "$force" ]
	then
		echo 'You can not say --force if you specifiy your own private key.'
		exit 1
	fi
else
	keyfile=$keypath
	ownpkey="false"
fi

# logfile location
if [ "$HOME" ]
then
	logfile="$HOME/makessl.log"
else
	logfile="/tmp/makessl.log"
fi

# replace asterisk with "wildcard" due to asterisk search in bash
file=${domain/\*/wildcard}
# if no custom private key defined use default path to private key
if [ "$ownpkey" != "true" ]
then
	keyfile="$keypath/$file.key"
fi

###################### ok path thingies enough.. let's go on

# prints the common name
echo ''
echo '---------------- Certificate Common Name ----------------'
echo $domain
echo ''

# prints the saving paths
echo '-------------------------- Path -------------------------'
if [ "$keyfile" == "$certpath" ]
then
	# just print one path if both is the same
	echo "Key/CSR: $certpath"
else
	# print both if different (e.g. debian standard path)
	echo "Private key: $keyfile
Certificate/CSR: $certpath
"
fi
echo "Log file: $logfile !! DISABLED !!"
echo ''

# check if files exist and renewal is not set
if [ -f $keyfile ] && [ "$force" != "true" ] && [ "$renewal" != "true" ] && [ "$ownpkey" != "true" ]
then
	echo '!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!'
	echo '!!!!!!!!!!!!!!!!!!!!!!!! Warning !!!!!!!!!!!!!!!!!!!!!!!!'
	echo '!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!'
	echo ''
	echo 'Private key already exists. Use --force to overwrite it.'
	echo 'Think about it carefully!'
	echo ''
	exit 1
	
	# at beginning i wanted to implement CTRL-C to abort but it was not safe enough
	# for i in 5 4 3 2 1
	# do
	# 	echo "$i.."
	# 	sleep 1
	# done
	# echo 'continue overwriting'
else
	# check if --force is set when --renewal is not set
	if [ "$force" == "true" ] && [ -f $keyfile ] && [ "$renewal" != "true" ] && [ "$ownpkey" != "true" ]
	then
		# remove existing private key
		rm $keyfile #&>> $logfile
		if [ $? -ne 0 ]
		then
			# print error (e.g. insufficient rights)
			echo 'Could not remove private key'
			exit 1
		else
			# warn if private key was overwritten
			echo '!!!!!!!!!!!!!!!!!!!!!!!! Warning !!!!!!!!!!!!!!!!!!!!!!!!'
			echo 'Existing private key overwritten with --force.'
			echo 'It is gone. Forever. Really'
		fi
		echo ''
	fi
fi

# build certificates subject string if exists as parameter
if [ "$country" ] ; then subject="/C=$country" ; fi
if [ "$state" ] ; then subject="$subject/ST=$state" ; fi
if [ "$locality" ] ; then subject="$subject/L=$locality" ; fi
if [ "$org" ] ; then subject="$subject/O=$org" ; fi
if [ "$orgunit" ] ; then subject="$subject/OU=$orgunit" ; fi
if [ "$domain" ] ; then	subject="$subject/CN=$domain" ; fi

# use existing key for CSR
if [ -f $keyfile ] && [ "$renewal" == "true" ] || [ "$ownpkey" == "true" ]
then
	# this will use the existing key for renewal/"rerequest" csr
	openssl req -out $certpath/$file.csr -new -key $keyfile -subj "$subject" #&>> $logfile
fi

# overwrite existing key or generate a new one
if [ -f $keyfile ] && [ "$force" == "true" ] || [ ! -f $keyfile ]
then
	# this will overwrite existing keys with the same name due to openssl command defaults
	openssl req -newkey rsa:2048 -subj "$subject" -nodes -keyout $keyfile -out $certpath/$file.csr #&>> $logfile
fi

# create self signed if user wishes that..
# because of lazyness (cacert.org/startssl.com) or whatever o.O
if [ -f $keyfile ] && [ "$selfsign" == "true" ]
then
	# this will genereate a self signed certificate
	openssl x509 -req -days 365 -in $certpath/$file.csr -signkey $keyfile -out $certpath/$file.crt #&>> $logfile
fi

# now comes the CSR/certificate thing
if [ $? -eq 0 ]
then
	if [ -f $certpath/$file.crt ] && [ "$selfsign" == "true" ]
	then
		# print some happyness if cert succeeded
		echo '------------------------ Success ------------------------'
		echo 'Certificate generated successfully.'
		echo ''
	else
		# print some happyness if csr succeeded
		echo '------------------------ Success ------------------------'
		echo 'Certificate signing request generated successfully.'
		echo ''
	fi

	# set rights on csr
	chmod 644 $certpath/$file.csr #&>> $logfile
	
	# print error if chmod failed
	if [ $? -eq 0 ]
	then
		echo 'CSR: rights on 644'
	else
		echo 'Could not set proper rights on CSR.'
	fi

	# set rights on private key
	chmod 600 $keyfile #&>> $logfile

	# print error if chmod failed
	if [ $? -eq 0 ]
	then
		echo 'Private key: rights on 600'
	else
		echo 'Could not set proper rights on private key.'
	fi
	echo ''
	
	# check private key owner which should be root
	if [ -f $keyfile ]
	then
		pkeyowner=`ls -l $keyfile | awk '{ print $3 }'`
	fi

	if [ "$pkeyowner" != "root" ] && [ -f $keyfile ]
	then
		echo '!!!!!!!!!!!!!!!!!!!!!!!! Warning !!!!!!!!!!!!!!!!!!!!!!!!'
		echo 'Owner of private key should be root.'
	fi
	
	if [ "$selfsign" != "true" ]
	then
		# show the generated csr (to copy/paste)
		echo ''
		cat $certpath/$file.csr
	fi
else
	echo "
Something went wrong with the openssl command, sorry.
I removed the trash for you. Just try it again.

Oh and have a look at the logfile: $logfile
	"
	# clean up the mess
	rm $certpath/$file.csr #&>> $logfile
	rm $certpath/$file.crt #&>> $logfile
	# remove when not renewal
	if [ "$renewal" != "true" ] && [ "$ownpkey" != "true" ]
	then
		rm $keyfile #&>> $logfile
	fi
	exit 1
fi

# everything okay here
exit 0
