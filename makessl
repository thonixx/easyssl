#!/bin/bash
#
# made by Michael Tanner
# https://github.com/thonixx/
#
# created at 24th of September 2012
# Use "git whatchanged" to get a more accurate date


#                                              m                        
#  mmmm    mmm    m mm   mmm   mmmmm   mmm   mm#mm   mmm    m mm   mmm  
#  #" "#  "   #   #"  " "   #  # # #  #"  #    #    #"  #   #"  " #   " 
#  #   #  m"""#   #     m"""#  # # #  #""""    #    #""""   #      """m 
#  ##m#"  "mm"#   #     "mm"#  # # #  "#mm"    "mm  "#mm"   #     "mmm" 
#  #                                                                    
#  " 


# OK, now we use getopt from util-linux
usage ()
{
echo "
Usage: ${0##*/}	-d domain
		[-c country] [-s state/canton] [-l city/village] [-o organisation] [-u orgunit]
		[ -p/--prefix prefix ] [-f folder] [--private-key] [--selfsign] [--renewal|force]
		[-h/--help]

Overview:
		generate an SSL certificate with some options

	most important thing:
	****
	-d domain       domain (asterisk for wildcard allowed)
	

	optional (required for class 3/EV):
	****
	-c country		Country the company resides
	-s state/canton		State or canton of the company
	-l city/village		City or village
	-o organisation		Name of your company
	-u unit			Organisation unit
	

	non-certificate-related options:
	****
	-p/--p			Prefix for file names (e.g.: SSL_...)
	-f folder		where to generate the CSR and private key
				Default: (`pwd`)
	--private-key		specify a custom private key
	--selfsign		self sign the certificate
	--force			force overwriting private key
	--renewal		uses existing key for renewal
	

	I need help:
	****
        -h/--help       this help
"
}
PARAM=`getopt -o d:c:s:l:o:u:p:f:h --long help,selfsign,renewal,force,prefix:,private-key: -- "$@"`

if [ "$?" -ne "0" ] ; then usage ; exit 1 ; fi

# ok I'm honest.. This part is copied from an existing script of a friend
eval set -- "$PARAM"
while true ; do
        case "$1" in
                -d) domain="${2}" ; shift 2 ;;
                -c) country="${2}"; shift 2 ;;  
		-s) state="${2}"; shift 2 ;;  
                -l) locality="${2}"; shift 2 ;;  
                -o) org="${2}"; shift 2 ;;  
                -u) orgunit="${2}"; shift 2 ;;  
                -f) customfolder="${2}"; shift 2 ;;  
                -p) prefix="${2}"; shift 2 ;;  
		--selfsign) selfsign="true"; shift ;;
		--prefix) prefix="${2}"; shift 2 ;;
		--private-key) pkey="${2}"; shift 2 ;;
		--force) force="true"; shift ;;
		--renewal) renewal="true"; shift ;;
                -h|--help) usage ; exit 0 ;;
                --) shift ; break ;;
                *) echo -e "Some weird error..\nI'm sorry.\nSomething with parameters is going wrong." ; exit 1 ;;
        esac
done

# we need at least a domain
if [ -z "$domain" ]; then echo "****
Can not execute script without domain.

Example: ${0##*/} -d domain.tld
****" ; usage ; exit 1; fi


#                  m    #            
#  mmmm    mmm   mm#mm  # mm    mmm  
#  #" "#  "   #    #    #"  #  #   " 
#  #   #  m"""#    #    #   #   """m 
#  ##m#"  "mm"#    "mm  #   #  "mmm" 
#  #                                 
#  " 


# special thing for myself. i always want to have a prefix :D
# i like advantages as a scripter ^^
if [ "`hostname`" == "woulfsystem76" ] && [ -z "$prefix" ]
then
	prefix="SSL_"
fi

# build the filename used for key/csr
# replace asterisk with "wildcard" due to asterisk search
filename="$prefix${domain/\*/wildcard}"

# define debian standard path
# for later implementation.. this could be useful with an option I think.. :/
certdebpath='/etc/ssl/certs/' # debian standard
keydebpath='/etc/ssl/private/' # debian standard

# default path is current working directory
keypath="`pwd`/"
certpath="`pwd`/"

# here are the default paths defined
keypath="$(echo $keypath | sed -e "s/\/*$//")/" # delete trailing slashes (also multiple ones)
certpath="$(echo $certpath | sed -e "s/\/*$//")/" # its just for beauty and proper directory handling..

# we need a folder
if [ "$customfolder" ]; # if custom folder on cli is defined
then
	# create folder if it does not exist
	if [ ! -d $customfolder ] ; then mkdir -p $customfolder 2>&1 | tee >> $logfile ; fi
	# print error if it fails (due to permissions or something like that)
	if [ ! -d $customfolder ] ; then echo "Could not create directory $customfolder for you." 2>&1 | tee >> $logfile ; fi

	# define the custom paths
	keypath="$(echo $customfolder | sed -e "s/\/*$//")/"
	certpath="$(echo $customfolder | sed -e "s/\/*$//")/"
fi

# logfile location
if [ "$HOME" ]
then
	logfile="$HOME/makessl.log"
else
	logfile="/tmp/makessl.log"
fi


#                  "                    m                  #                   
#  mmmm    m mm  mmm    m   m   mmm   mm#mm   mmm          #   m   mmm   m   m 
#  #" "#   #"  "   #    "m m"  "   #    #    #"  #         # m"   #"  #  "m m" 
#  #   #   #       #     #m#   m"""#    #    #""""         #"#    #""""   #m#  
#  ##m#"   #     mm#mm    #    "mm"#    "mm  "#mm"         #  "m  "#mm"   "#   
#  #                                                                      m"   
#  "                                                                     ""


# check for custom private key
if [ "$pkey" ]
then
	# check if custom key exists
	if [ -f $pkey ]
	then
		# put custom private key in variable
		keyfile=$pkey
		ownpkey="true" # this is used to better check for custom private key later

		if [ "$force" ]
		then
			# if custom key is specified you can not overwrite the custom key
			echo 'You can not overwrite your custom private key.'
			echo 'Move it away or delete the private key first.'
			exit 1
		fi
	else
		# print error when private key does not exist
		echo 'The private key seems to not exist. Maybe permission problem?'
		exit 1
	fi
else
	# take the default name for private key if it should be created
	keyfile="$keypath$filename.key"
	# this is used to better check that no custom private key is used later
	ownpkey="false"
fi

# check if private key already exists and if renewal is not set
if [ -f $keyfile ] && [ "$force" != "true" ] && [ "$renewal" != "true" ] && [ "$ownpkey" != "true" ]
then
	echo '------------------------ Warning ------------------------'
	echo 'Private key already exists. Use --force to overwrite it.'
	echo 'Think about it carefully!'
	echo ''
	exit 1
else
	# check if --force is set when --renewal is not set
	if [ "$force" == "true" ] && [ -f $keyfile ] && [ "$renewal" != "true" ] && [ "$ownpkey" != "true" ]
	then
		# remove existing private key
		rm $keyfile 2>&1 | tee >> $logfile
		if [ "$?" -ne 0 ]
		then
			# print error (e.g. insufficient rights)
			echo 'Could not remove private key. :('
			echo 'Maybe I do not have permission to do that.'
			echo ''
			exit 1
		else
			# warn if private key was overwritten
			echo '------------------------- Info --------------------------'
			echo 'Existing private key overwritten with --force.'
			echo 'It is gone. Forever. Really. No joke. For sure ;).'
			echo ''
		fi
	fi
fi


# 
#   mmm   m   m  mmmmm  mmmmm   mmm    m mm  m   m 
#  #   "  #   #  # # #  # # #  "   #   #"  " "m m" 
#   """m  #   #  # # #  # # #  m"""#   #      #m#  
#  "mmm"  "mm"#  # # #  # # #  "mm"#   #      "#   
#                                             m"   
#                                            ""


# prints the common name
echo ''
echo '---------------- Certificate Common Name ----------------'
echo $domain
echo ''

# prints the saving paths
echo '-------------------------- Path -------------------------'
if [ "$ownpkey" != "true" ]
then
	# just print one path if both is the same
	echo "Key/CSR: $certpath"
else
	# print both if different (e.g. debian standard path)
	echo "Private key: $keyfile"
	echo "Cert/CSR: $certpath"
fi
echo "Log file: $logfile"
echo ''


#                                                     "                 
#  mmmm    m mm   mmm    mmm    mmm    mmm    mmm   mmm    m mm    mmmm 
#  #" "#   #"  " #" "#  #"  "  #"  #  #   "  #   "    #    #"  #  #" "# 
#  #   #   #     #   #  #      #""""   """m   """m    #    #   #  #   # 
#  ##m#"   #     "#m#"  "#mm"  "#mm"  "mmm"  "mmm"  mm#mm  #   #  "#m"# 
#  #                                                               m  # 
#  "                                                                ""  
# 


# build certificates subject string if exists as parameter
if [ "$country" ] ; then subject="/C=$country" ; fi
if [ "$state" ] ; then subject="$subject/ST=$state" ; fi
if [ "$locality" ] ; then subject="$subject/L=$locality" ; fi
if [ "$org" ] ; then subject="$subject/O=$org" ; fi
if [ "$orgunit" ] ; then subject="$subject/OU=$orgunit" ; fi
if [ "$domain" ] ; then	subject="$subject/CN=$domain" ; fi

# use existing key for CSR if it exists (should be checked above .. but this is more secure if sth fails)
if [ -f $keyfile ] && [ "$renewal" == "true" ] || [ -f $keyfile ] && [ "$ownpkey" == "true" ]
then
	# this will use the existing key for renewal/"rerequest" csr
	openssl req -out $certpath$filename.csr -new -key $keyfile -subj "$subject" 2>&1 | tee >> $logfile
fi

# overwrite existing key or generate a new one
if [ -f $keyfile ] && [ "$force" == "true" ] || [ ! -f $keyfile ]
then
	# this will overwrite existing keys with the same name due to openssl command defaults
	openssl req -newkey rsa:2048 -subj "$subject" -nodes -keyout $keyfile -out $certpath$filename.csr 2>&1 | tee >> $logfile
fi

# create self signed if user wishes that..
# because of lazyness (cacert.org/startssl.com) or whatever o.O
if [ -f $keyfile ] && [ "$selfsign" == "true" ]
then
	# this will genereate a self signed certificate
	openssl x509 -req -days 365 -in $certpath$filename.csr -signkey $keyfile -out $certpath$filename.crt 2>&1 | tee >> $logfile
fi

# now comes the CSR/certificate thing
if [ "$?" -eq 0 ]
then
	if [ -f $certpath$filename.crt ] && [ "$selfsign" == "true" ]
	then
		# print some happyness if cert succeeded
		echo '------------------------ Success ------------------------'
		echo 'Certificate generated successfully.'
		echo ''
	else
		# print some happyness if csr succeeded
		echo '------------------------ Success ------------------------'
		echo 'Certificate signing request generated successfully.'
		echo ''
	fi

	# set rights on csr
	chmod 644 $certpath$filename.csr 2>&1 | tee >> $logfile
	
	# print error if chmod failed
	if [ "$?" -eq 0 ]
	then
		echo 'CSR: rights on 644'
	else
		echo 'Could not set proper rights on CSR.'
	fi

	# set rights on private key
	chmod 600 $keyfile 2>&1 | tee >> $logfile

	# print error if chmod failed
	if [ "$?" -eq 0 ]
	then
		echo 'Private key: rights on 600'
	else
		echo 'Could not set proper rights on private key.'
	fi
	echo ''
	
	# check private key owner which should be root
	if [ -f "$keyfile" ]
	then
		pkeyowner=`ls -l $keyfile | awk '{ print $3 }'`
	fi

	if [ "$pkeyowner" != "root" ] && [ -f $keyfile ]
	then
		echo '!!!!!!!!!!!!!!!!!!!!!!!! Warning !!!!!!!!!!!!!!!!!!!!!!!!'
		echo 'Owner of private key should be root.'
	fi
	
	if [ "$selfsign" != "true" ]
	then
		# show the generated csr (to copy/paste)
		echo ''
		cat $certpath$filename.csr
	fi
else
	echo "
Something went wrong with the openssl command, sorry.
I removed the trash for you. Just try it again.

Oh and have a look at the logfile: $logfile
	"
	# clean up the mess
	rm $certpath$filename.csr 2>&1 | tee >> $logfile
	rm $certpath$filename.crt 2>&1 | tee >> $logfile
	# remove when not renewal
	if [ "$renewal" != "true" ] && [ "$ownpkey" != "true" ]
	then
		rm $keyfile 2>&1 | tee >> $logfile
	fi
	exit 1
fi

# everything okay here
exit 0
